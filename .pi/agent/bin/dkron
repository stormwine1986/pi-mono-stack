#!/usr/bin/env node

/**
 * .pi/agent/bin/dkron
 * 
 * 专门用于操作 Dkron API 的脚本
 */

import { spawnSync } from 'node:child_process';
import { randomBytes } from 'node:crypto';

const DKRON_PORT = 18047;
const DKRON_URL = `http://127.0.0.1:${DKRON_PORT}/v1`;

const args = process.argv.slice(2);

// ── Help text ───────────────────────────────────────────────

const HELP = `
Usage: dkron <command> [options]

Commands:
  status                 Get Dkron subsystem status
  job ls [options]       List jobs with filtering and sorting
  job create [options]   Create or update a job
  job run <name>         Run a job immediately
  job delete <name>      Delete a job by name
  job logs <name> [opt]  Show execution logs for a job

Options for job ls:
  --name <name>          Filter by exact job name
  --query <keyword>      Filter jobs containing keyword in name or description
  --sort <asc|desc>      Sort by next execution time (default: desc, near to far)

Options for job create:
  --displayname <desc>   Nice name for the job (description)
  --schedule <expr>      Cron expression or "@at <ISO8601>" or "@every <duration>" (required)
  --command <cmd>        Command to execute (required for shell/background)
  --message <msg>        Message for the reminder (required for reminder)
  --executor <name>      Executor to use (default: background)
  --timeout <duration>   Job timeout (e.g. 10s, 5m)
  --env <KEY=VALUE>      Environment variables (can be used multiple times)

Options for job logs:
  --last                 Show only the most recent execution (including running)

Examples:
  # Periodic job (every 1 minute)
  dkron job create --schedule "@every 1m" --command "echo periodic"

  # Future one-time job (UTC time)
  dkron job create --displayname "New Year Task" --schedule "@at 2026-12-31T23:59:00Z" --command "echo year-end"

  # Reminder job
  dkron job create --executor reminder --schedule "@every 5m" --message "Time to drink water"

  # Find a specific job by name or keyword
  dkron job ls --name test-job
  dkron job ls --query "backup"

  # Check the most recent execution of a job (including output)
  dkron job logs test-job --last

  # Run / delete a job
  dkron job run test-job
  dkron job delete test-job
`;

// ── Utilities ───────────────────────────────────────────────

function getFlag(flagName, list = args) {
    const index = list.indexOf(`--${flagName}`);
    if (index !== -1 && index + 1 < list.length) {
        return list[index + 1];
    }
    return null;
}

function getFlags(flagName, list = args) {
    const values = [];
    for (let i = 0; i < list.length; i++) {
        if (list[i] === `--${flagName}` && i + 1 < list.length) {
            values.push(list[i + 1]);
        }
    }
    return values;
}

function hasFlag(flagName, list = args) {
    return list.includes(`--${flagName}`);
}

function showHelp() {
    console.log(HELP);
    process.exit(0);
}

function needsHelp(list = args) {
    return list.length === 0 || list.includes('-h') || list.includes('--help');
}

function generateId(size = 12) {
    const alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let id = '';
    const bytes = randomBytes(size);
    for (let i = 0; i < size; i++) {
        id += alphabet[bytes[i] % alphabet.length];
    }
    return id;
}

async function callDkron(path, method = 'GET', data = null) {
    const url = `${DKRON_URL}${path}`;
    const curlArgs = ['-sS', '-X', method, url];

    if (data) {
        curlArgs.push('-H', 'Content-Type: application/json');
        curlArgs.push('-d', JSON.stringify(data));
    }

    const result = spawnSync('curl', curlArgs, { encoding: 'utf8' });

    if (result.status !== 0) {
        console.error('Error calling Dkron API:');
        console.error('Exit code:', result.status);
        console.error('Stderr:', result.stderr);
        process.exit(1);
    }

    if (!result.stdout) return null;

    try {
        return JSON.parse(result.stdout);
    } catch (e) {
        return result.stdout;
    }
}

// ── Top-level routing ───────────────────────────────────────

if (needsHelp()) showHelp();

const command = args[0];
const subArgs = args.slice(1);

switch (command) {
    case 'status': {
        const res = await callDkron('');
        console.log(JSON.stringify(res, null, 2));
        break;
    }
    case 'job': {
        if (needsHelp(subArgs)) showHelp();
        const action = subArgs[0];
        const actionArgs = subArgs.slice(1);

        switch (action) {
            // ── job ls ──────────────────────────────────────
            case 'ls': {
                const nameFilter = getFlag('name', actionArgs);
                const queryFilter = getFlag('query', actionArgs);
                const sortOrder = getFlag('sort', actionArgs) || 'desc';

                let jobs = await callDkron('/jobs');
                if (!Array.isArray(jobs)) {
                    console.log(jobs || 'No jobs found');
                    break;
                }

                if (nameFilter) {
                    jobs = jobs.filter(j => j.name === nameFilter);
                }

                if (queryFilter) {
                    const q = queryFilter.toLowerCase();
                    jobs = jobs.filter(j =>
                        (j.name && j.name.toLowerCase().includes(q)) ||
                        (j.displayname && j.displayname.toLowerCase().includes(q))
                    );
                }

                jobs.sort((a, b) => {
                    const timeA = a.next && !a.next.startsWith('0001') ? new Date(a.next).getTime() : 0;
                    const timeB = b.next && !b.next.startsWith('0001') ? new Date(b.next).getTime() : 0;
                    return sortOrder === 'desc' ? timeB - timeA : timeA - timeB;
                });

                console.log(JSON.stringify(jobs, null, 2));
                break;
            }
            // ── job create ──────────────────────────────────
            case 'create': {
                const schedule = getFlag('schedule', actionArgs);
                const cmd = getFlag('command', actionArgs);
                const message = getFlag('message', actionArgs);
                const displayname = getFlag('displayname', actionArgs);
                const executor = getFlag('executor', actionArgs) || 'background';
                const timeout = getFlag('timeout', actionArgs);
                const envs = getFlags('env', actionArgs);

                if (!schedule) {
                    console.error('Error: --schedule is required');
                    process.exit(1);
                }

                if (executor === 'reminder' && !message) {
                    console.error('Error: --message is required for reminder executor');
                    process.exit(1);
                }

                if (executor !== 'reminder' && !cmd) {
                    console.error('Error: --command is required');
                    process.exit(1);
                }

                const name = generateId();
                const jobData = {
                    name,
                    schedule,
                    displayname: displayname || undefined,
                    executor: executor,
                    executor_config: {
                        command: cmd || undefined,
                        message: message || undefined,
                        timeout: timeout || undefined,
                        env: envs.length > 0 ? JSON.stringify(envs) : undefined
                    }
                };

                const res = await callDkron('/jobs', 'POST', jobData);
                console.log(`Job created successfully: ${name}`);
                console.log(JSON.stringify(res, null, 2));
                break;
            }
            // ── job run ─────────────────────────────────────
            case 'run': {
                const name = actionArgs[0];
                if (!name || name.startsWith('-')) {
                    console.error('Error: job name is required');
                    process.exit(1);
                }
                const res = await callDkron(`/jobs/${name}`, 'POST');
                console.log(JSON.stringify(res, null, 2));
                break;
            }
            // ── job delete ──────────────────────────────────
            case 'delete': {
                const name = actionArgs[0];
                if (!name || name.startsWith('-')) {
                    console.error('Error: job name is required');
                    process.exit(1);
                }
                const res = await callDkron(`/jobs/${name}`, 'DELETE');
                console.log(JSON.stringify(res, null, 2));
                break;
            }
            // ── job logs ────────────────────────────────────
            case 'logs': {
                const name = actionArgs[0];
                if (!name || name.startsWith('-')) {
                    console.error('Error: job name is required');
                    process.exit(1);
                }
                const lastOnly = hasFlag('last', actionArgs);

                let res = await callDkron(`/jobs/${name}/executions`);
                if (!Array.isArray(res)) {
                    console.log(JSON.stringify(res, null, 2));
                    break;
                }

                res.sort((a, b) => new Date(b.started_at) - new Date(a.started_at));

                if (lastOnly && res.length > 0) {
                    console.log(JSON.stringify(res[0], null, 2));
                } else {
                    console.log(JSON.stringify(res, null, 2));
                }
                break;
            }
            default:
                console.error(`Unknown job action: ${action}`);
                console.error(`Run 'dkron -h' for usage.`);
                process.exit(1);
        }
        break;
    }
    default:
        console.error(`Unknown command: ${command}`);
        console.error(`Run 'dkron -h' for usage.`);
        process.exit(1);
}
